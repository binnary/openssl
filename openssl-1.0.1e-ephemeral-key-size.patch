Index: openssl-1.0.1j/apps/s_apps.h
===================================================================
--- openssl-1.0.1j.orig/apps/s_apps.h	2014-10-16 15:32:12.296991439 +0300
+++ openssl-1.0.1j/apps/s_apps.h	2014-10-16 15:32:12.288991439 +0300
@@ -156,6 +156,7 @@
 int set_cert_stuff(SSL_CTX *ctx, char *cert_file, char *key_file);
 int set_cert_key_stuff(SSL_CTX *ctx, X509 *cert, EVP_PKEY *key);
 #endif
+int ssl_print_tmp_key(BIO *out, SSL *s);
 int init_client(int *sock, char *server, char *port, int type);
 int should_retry(int i);
 int extract_host_port(char *str,char **host_ptr,char **port_ptr);
Index: openssl-1.0.1j/apps/s_cb.c
===================================================================
--- openssl-1.0.1j.orig/apps/s_cb.c	2014-10-16 15:32:12.296991439 +0300
+++ openssl-1.0.1j/apps/s_cb.c	2014-10-16 15:32:12.288991439 +0300
@@ -338,6 +338,38 @@
 		}
 	}
 
+int ssl_print_tmp_key(BIO *out, SSL *s)
+	{
+	EVP_PKEY *key;
+	if (!SSL_get_server_tmp_key(s, &key))
+		return 1;
+	BIO_puts(out, "Server Temp Key: ");
+	switch (EVP_PKEY_id(key))
+		{
+	case EVP_PKEY_RSA:
+		BIO_printf(out, "RSA, %d bits\n", EVP_PKEY_bits(key));
+		break;
+
+	case EVP_PKEY_DH:
+		BIO_printf(out, "DH, %d bits\n", EVP_PKEY_bits(key));
+		break;
+
+	case EVP_PKEY_EC:
+			{
+			EC_KEY *ec = EVP_PKEY_get1_EC_KEY(key);
+			int nid;
+			const char *cname;
+			nid = EC_GROUP_get_curve_name(EC_KEY_get0_group(ec));
+			EC_KEY_free(ec);
+			cname = OBJ_nid2sn(nid);
+			BIO_printf(out, "ECDH, %s, %d bits\n",
+						cname, EVP_PKEY_bits(key));
+			}
+		}
+	EVP_PKEY_free(key);
+	return 1;
+	}
+		
 
 void MS_CALLBACK msg_cb(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg)
 	{
Index: openssl-1.0.1j/apps/s_client.c
===================================================================
--- openssl-1.0.1j.orig/apps/s_client.c	2014-10-16 15:32:12.296991439 +0300
+++ openssl-1.0.1j/apps/s_client.c	2014-10-16 15:32:12.288991439 +0300
@@ -2044,6 +2044,8 @@
 			BIO_write(bio,"\n",1);
 			}
 
+		ssl_print_tmp_key(bio, s);
+
 		BIO_printf(bio,"---\nSSL handshake has read %ld bytes and written %ld bytes\n",
 			BIO_number_read(SSL_get_rbio(s)),
 			BIO_number_written(SSL_get_wbio(s)));
Index: openssl-1.0.1j/ssl/ssl.h
===================================================================
--- openssl-1.0.1j.orig/ssl/ssl.h	2014-10-16 15:32:12.296991439 +0300
+++ openssl-1.0.1j/ssl/ssl.h	2014-10-16 15:32:12.288991439 +0300
@@ -1587,6 +1587,8 @@
 
 #define SSL_CTRL_CHECK_PROTO_VERSION		119
 
+#define SSL_CTRL_GET_SERVER_TMP_KEY		109
+
 #define DTLSv1_get_timeout(ssl, arg) \
 	SSL_ctrl(ssl,DTLS_CTRL_GET_TIMEOUT,0, (void *)arg)
 #define DTLSv1_handle_timeout(ssl) \
@@ -1628,6 +1630,9 @@
 #define SSL_CTX_clear_extra_chain_certs(ctx) \
 	SSL_CTX_ctrl(ctx,SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS,0,NULL)
 
+#define SSL_get_server_tmp_key(s, pk) \
+	SSL_ctrl(s,SSL_CTRL_GET_SERVER_TMP_KEY,0,pk)
+
 #ifndef OPENSSL_NO_BIO
 BIO_METHOD *BIO_f_ssl(void);
 BIO *BIO_new_ssl(SSL_CTX *ctx,int client);
Index: openssl-1.0.1j/ssl/s3_lib.c
===================================================================
--- openssl-1.0.1j.orig/ssl/s3_lib.c	2014-10-16 15:32:12.296991439 +0300
+++ openssl-1.0.1j/ssl/s3_lib.c	2014-10-16 15:38:20.204978123 +0300
@@ -3356,6 +3356,45 @@
 
 #endif /* !OPENSSL_NO_TLSEXT */
 
+	case SSL_CTRL_GET_SERVER_TMP_KEY:
+		if (s->server || !s->session || !s->session->sess_cert)
+			return 0;
+		else
+			{
+			SESS_CERT *sc;
+			EVP_PKEY *ptmp;
+			int rv = 0;
+			sc = s->session->sess_cert;
+#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC)
+			if (!sc->peer_rsa_tmp && !sc->peer_dh_tmp
+							&& !sc->peer_ecdh_tmp)
+				return 0;
+#endif
+			ptmp = EVP_PKEY_new();
+			if (!ptmp)
+				return 0;
+			if (0);
+#ifndef OPENSSL_NO_RSA
+			else if (sc->peer_rsa_tmp)
+				rv = EVP_PKEY_set1_RSA(ptmp, sc->peer_rsa_tmp);
+#endif
+#ifndef OPENSSL_NO_DH
+			else if (sc->peer_dh_tmp)
+				rv = EVP_PKEY_set1_DH(ptmp, sc->peer_dh_tmp);
+#endif
+#ifndef OPENSSL_NO_ECDH
+			else if (sc->peer_ecdh_tmp)
+				rv = EVP_PKEY_set1_EC_KEY(ptmp, sc->peer_ecdh_tmp);
+#endif
+			if (rv)
+				{
+				*(EVP_PKEY **)parg = ptmp;
+				return 1;
+				}
+			EVP_PKEY_free(ptmp);
+			return 0;
+			}
+
 	case SSL_CTRL_CHECK_PROTO_VERSION:
 		/* For library-internal use; checks that the current protocol
 		 * is the highest enabled version (according to s->ctx->method,
